---
title: "LocationDuplicates"
output: html_document
---

lat = x 
long = y

```{r}
library(dplyr)
library(ggplot2)
library(janitor)
library(tidyr)
library(tidyverse)
library(sf)

```

Read in Data
```{r}
CoinFinds = read.csv("CoinData/CoinFinds.csv")
CoinGroups = read.csv("CoinData/CoinGroups.csv")
```

*** Testing
Check for NAs - none for lat and longitude
```{r}
colSums(is.na(CoinFinds))
```

This code creates the data frame "ClosestNeighbor.CF", which puts the information of the closet geographical neighbor by lattitude and longitude on the same line. The neighboring data's headings have "n." added to them. 

The code is currently set for distance to be in km. Switching which d is used in the code below can change it to degrees.
```{r}
# library(rgeos)
# library(sp)
# library(geosphere)
# 
# GEO_cf = CoinFinds
# coordinates(GEO_cf) = ~cf_custom_y_coordinate+cf_custom_x_coordinate
# 
# #d = gDistance(GEO_cf, byid=T) # distance in km
# d = distm(GEO_cf) # distance in degrees
# 
# min.d <- apply(d, 1, function(x) order(x, decreasing=F)[2])
# 
# ClosestN.CF <- cbind(CoinFinds, CoinFinds[min.d,], apply(d, 1, function(x) sort(x, decreasing=F)[2]))
# 
# colnames(ClosestN.CF) <- c(colnames(CoinFinds), "n.ID", "n.cf_name", "n.cf_place_name", "n.cf_custom_place_name", "n.cf_custom_x_coordinate", "n.cf_custom_y_coordinate", "n.cf_custom_region", "n.cf_custom_region_vague", "n.cf_excavation_name", "n.cf_excavation", "n.cf_excavation_start", "n.cf_excavation_end", "n.cf_single_find", "n.cf_hoard", "n.cf_start_year", "n.cf_end_year", "n.cf_vague", "n.cf_num_coins_found", "n.cf_publication_ref", "n.cf_user", "n.cf_comment", "n.cf_date_entered", "n.Coin.Find.Search", "n.Coin.Find.Json", "n.Exported.at", "distance")
# 
# #Ordering ClosestN.CF by distance
# 
```

Isolating those that have a distance from each other equal to zero
```{r}
# #Ordering ClosestN.CF by distance
# #ClosestN.CF = ClosestN.CF[order(ClosestN.CF$distance),]
# 
# ClosestEqualsZero = ClosestN.CF[ClosestN.CF$distance==0,]
# 
# ClosestEqualsOther = ClosestN.CF[ClosestN.CF$distance>0,]
# 
# OverviewOfEqualZero = data.frame(
#   
#   ID = ClosestEqualsZero$ID,
#   CF = ClosestEqualsZero$cf_name,
#   
#   Neighbor_ID = ClosestEqualsZero$n.ID,
#   Neighboring_CF = ClosestEqualsZero$n.cf_name,
#   
#   Latitude = ClosestEqualsZero$cf_custom_x_coordinate,
#   Longitude = ClosestEqualsZero$cf_custom_y_coordinate,
#   Neighbor_Latitude = ClosestEqualsZero$n.cf_custom_x_coordinate,
#   Neighbor_Longitude = ClosestEqualsZero$n.cf_custom_y_coordinate,
#   
#   distance = ClosestEqualsZero$distance
# 
# )
# 
# 
# OverviewEqualsOther = data.frame(
#   
#   ID = ClosestEqualsOther$ID,
#   CF = ClosestEqualsOther$cf_name,
#   
#   Neighbor_ID = ClosestEqualsOther$n.ID,
#   Neighboring_CF = ClosestEqualsOther$n.cf_name,
#   
#   Latitude = ClosestEqualsOther$cf_custom_x_coordinate,
#   Longitude = ClosestEqualsOther$cf_custom_y_coordinate,
#   Neighbor_Latitude = ClosestEqualsOther$n.cf_custom_x_coordinate,
#   Neighbor_Longitude = ClosestEqualsOther$n.cf_custom_y_coordinate,
#   
#   distance = ClosestEqualsOther$distance
# 
# )
# 
# 
# # I've noticed that for some points, it will list the closet value to it as itself. These points only seem to be those that are already listed as the closest to another point. So I think it's fine if I strip them out?
# 
# # This works for now as a preliminary solution, but I will definetly want to check to see if this correct. 
# # For now, I am stripping out ones that repeat 

```
*****

Functions
```{r}
# Function for finding excavation start years from IDs
ID_toget_start = function(ID) {
  nums_list <- rep(NULL, length(ID))
  for (i in c(1:length(ID))) {
    row = Cut_CoinFinds[Cut_CoinFinds$ID==ID[i],][1,]
    nums_list[i] = row$cf_excavation_start
  }
  return(nums_list)
}

# Function for finding excavation end years from IDs
ID_toget_end = function(ID) {
  nums_list <- rep(NULL, length(ID))
  for (i in c(1:length(ID))) {
    row = Cut_CoinFinds[Cut_CoinFinds$ID==ID[i],][1,]
    nums_list[i] = row$cf_excavation_end
  }
  return(nums_list)
}
##########

# Function for finding start years from IDs
ID_toget_startyear = function(ID) {
  nums_list <- rep(NULL, length(ID))
  for (i in c(1:length(ID))) {
    row = Cut_CoinFinds[Cut_CoinFinds$ID==ID[i],][1,]
    nums_list[i] = row$cf_start_year
  }
  return(nums_list)
}

# Function for finding start years from IDs
ID_toget_endyear = function(ID) {
  nums_list <- rep(NULL, length(ID))
  for (i in c(1:length(ID))) {
    row = Cut_CoinFinds[Cut_CoinFinds$ID==ID[i],][1,]
    nums_list[i] = row$cf_end_year
  }
  return(nums_list)
}

# function that will output number of coins found from an coin find ID
ID_toget_numCoins = function(ID) {
  nums_list <- rep(NULL, length(ID))
  for (i in c(1:length(ID))) {
    row = CoinFinds[CoinFinds$ID==ID[i],][1,]
    nums_list[i] = row$cf_num_coins_found
  }
  return(nums_list)
}

# function that will output list of coin group IDs from a coin find ID
CF_to_CG = function(cf_IDs) {
  
 # for (i in c(1:length(cf_IDs))) {
    
  row = CoinGroups[CoinGroups$cfID==cf_IDs,]
  nums_list = row$cgID
    
#  }
  return(nums_list)
  
}

```


# Initial Changing of CoinFinds (QUESTION)
```{r}

for( i in c(1:nrow(CoinFinds))) {
  
  # using CoinGroups to replace NA values in cf_num_coins_found
  # issue with this, some of the coins in the coin groups are also listed as NA
   if(is.na(CoinFinds$cf_num_coins_found[i])) {
     
    CGs = CoinGroups[CoinGroups$cfID==CoinFinds$ID[i],]
    print(CoinFinds$ID[i])
    Sum = sum(CGs$cg_num_coins)
    CoinFinds$cf_num_coins_found[i] = Sum
     
   }
  
}

#### 10019 still NA because its NA in Coin Groups file.
# taking out rows where cf_num_coins_found is equal to 0
#CoinFinds = CoinFinds[CoinFinds$cf_num_coins_found != 0 & !is.na(CoinFinds$cf_num_coins_found),]

```

Location Filter: For each coin find location, return all coin finds within a certain radius in a list, forming a column of the dataframe CoinFinds (DONE)
```{r}
#####INPUT####
RADIUS = 1000
##############

cf_nrow = nrow(CoinFinds) - 2000
CoinFinds$in.radius = NA
CoinFinds$num.in.radius = NA

### Using the sf package, creating spatial objects out of each coin find's lat and long points
longitude_list = CoinFinds$cf_custom_y_coordinate
latitude_list = CoinFinds$cf_custom_x_coordinate
IDs_list = CoinFinds$ID
# target point
target <- data_frame(ID = IDs_list, longitude = longitude_list, latitude = latitude_list)
# Specify the source of lat and long coordinates
target_sf <- st_as_sf(target, coords = c("longitude", "latitude"))
st_crs(target_sf) <- 4326

for (i in c(1:cf_nrow)) {
  index = i

  # creating sf spatial object out of the central point in radius
  point_ID = CoinFinds$ID[index]
  point <- data_frame(ID = point_ID, mylon = CoinFinds$cf_custom_y_coordinate[index], mylat = CoinFinds$cf_custom_x_coordinate[index]) 
  point_sf <- st_as_sf(point, coords = c("mylon", "mylat"))
  st_crs(point_sf) <- 4326
  
  #  filter records within the RADIUS specified (THE SECTION THAT SLOWS DOWN FOR-LOOP)
  target_sf2 <- target_sf %>%
    mutate(Dist = as.numeric(st_distance(point_sf, target_sf, by_element = TRUE))) %>%
    filter(Dist <= RADIUS)
  
  #adding IDs of coin finds in radius to CoinFinds data frame
  test.target = target_sf2 %>% as_tibble()
  rad.IDs = list(test.target$ID)
  CoinFinds$in.radius[index] = I(rad.IDs)
  CoinFinds$num.in.radius[index] = length(test.target$ID)
}


# filtering on points that only have themselves as closest point. Going forward, this is the data frame that will entries struck from it if they are not of interest. In the end, it will contain only finds that need attention.
# Ok on second though, I may just carry through with the whole Data Frame and make cuts at the end
Cut_CoinFinds = CoinFinds

```

Quantity Filter (DONE)
```{r}

#cutting it at where the previous for loop stopped
Cut_CoinFinds = Cut_CoinFinds[1:3084,]

####INPUT#### 
RANGE = 5
#############


# This creates another row in Cut_CoinFinds that returns a list of TRUE/FALSE for each coin find in the radius. TRUE: the number of coins found for a coin find are equal to (+/- a range set by user) the total coins found for the central coin find. FALSE: not the same within a certain range set by user
for (z in c(1:nrow(Cut_CoinFinds))) {
  index = z
  point_ID = Cut_CoinFinds$ID[index]
  point_coins = Cut_CoinFinds$cf_num_coins_found[index]
  rad.IDs = Cut_CoinFinds$in.radius[index][[1]]
  numCoinsList = ID_toget_numCoins(rad.IDs)
  
  are.num.coins.same = rep(NULL, length(numCoinsList))
  for (o in c(1:length(numCoinsList))) {
    
    if (is.na(numCoinsList[o])) {
      are.num.coins.same[o] = NA
      next
    }
    
    if (numCoinsList[o] <= (point_coins+RANGE) & 
        numCoinsList[o] >= (point_coins-RANGE)){
      are.num.coins.same[o] = TRUE
    } else {
      are.num.coins.same[o] = FALSE  }}

  Cut_CoinFinds$are.num.coins.same[index] = I(list(are.num.coins.same))

}


```

NOTES

Metal Filter
```{r}

####INPUT#### 
RANGE = 5
#############

for (z in c(1:nrow(Cut_CoinFinds))) {
  index = z
  
  point_ID = Cut_CoinFinds$ID[index]
  point_cgIDs = CF_to_CG(point_ID)
  # need to find metals for the point as well.
  
  rad.IDs = Cut_CoinFinds$in.radius[index][[1]]
  
  CoinGroups$which.metals.are.same = NA
#  rad.IDS = list(rad.IDs)
  
  # For each coin find within the main point's radius, which have the same amounts of the same metals (And which metals are the same; create a metal.radius.same column?)?
  for (o in c(1:length(rad.IDs))) {
    
    CGs = CoinGroups[CoinGroups$cfID==rad.IDs[o],]
    
    # How do I figure out how to find the metal of each coin type?
          # Write a function? or find a way to export it?
    
    # Once you get a list of which metals correspond to which coin amount, 
    # then you can subset it by each type of denomination
    # so you will get silver, gold, and bronze variables
    
    
    # CHANGE Final if statements to get into comparing amounts

    
  #Add to Cut_CoinFinds
 # Cut_CoinFinds$are.num.coins.same[index] = I(list(are.num.coins.same))

}

}

```
Questions

Excavation Year Filter (DONE)
```{r}
####INPUT####
START_RANGE = 3
END_RANGE = 3
#############

for (z in c(1:nrow(Cut_CoinFinds))) {
  index = z

  if(is.na(Cut_CoinFinds$cf_excavation_start[index])) {
    next
  }
  if(is.na(Cut_CoinFinds$cf_excavation_end[index])) {
    next
  }
  
  #start year
  point_ID = Cut_CoinFinds$ID[index]
  excav_start = Cut_CoinFinds$cf_excavation_start[index]
  rad.IDs = Cut_CoinFinds$in.radius[index][[1]]
  excav_start_list = ID_toget_start(rad.IDs) 
  
  #end year
  excav_end = Cut_CoinFinds$cf_excavation_end[index]
  rad.IDs = Cut_CoinFinds$in.radius[index][[1]]
  excav_end_list = ID_toget_end(rad.IDs) 


  are.excav.start.same = rep(NULL, length(numCoinsList))
  are.excav.end.same = rep(NULL, length(numCoinsList))
  for (o in c(1:length(excav_end_list))) {
    
    # testing if start year same within range
     if (is.na(excav_start_list[o])) {
      are.num.coins.same[o] = NA
      next}
    if (excav_start_list[o] <= (excav_start+START_RANGE) & 
        excav_start_list[o] >= (excav_start-START_RANGE)){
      are.excav.start.same[o] = TRUE
    } else {
      are.excav.start.same[o] = FALSE  }
    
    # testing if end year same within range
     if (is.na(excav_end_list[o])) {
      are.excav.end.same[o] = NA
      next}
    if (excav_end_list[o] <= (excav_end+END_RANGE) & 
        excav_end_list[o] >= (excav_end-END_RANGE)){
      are.excav.end.same[o] = TRUE
    } else {
      are.excav.end.same[o] = FALSE  }
    
    }

  Cut_CoinFinds$are.excav.start.same[index] = I(list(are.excav.start.same))
  Cut_CoinFinds$are.excav.end.same[index] = I(list(are.excav.end.same))

}

```

Why are some excavation boundaries still put in even though excavation is listed as false. 

Excavation years themselves are NAs. 

if hoard is NA, skip to the next step

Date Range  DONE
```{r}
####INPUT####
EARLY_DATE = 3
LATE_DATE = 3
#############

# screening out NAs
for (z in c(1:30)) {
  index = z

  if(is.na(Cut_CoinFinds$cf_start_year[index])) {
    next
  }
  if(is.na(Cut_CoinFinds$cf_end_year[index])) {
    next
  }
  
  #start year
  point_ID = Cut_CoinFinds$ID[index]
  start_year = Cut_CoinFinds$cf_start_year[index]
  rad.IDs = Cut_CoinFinds$in.radius[index][[1]]
  start_year_list = ID_toget_startyear(rad.IDs) 
  
  #end year
  end_year = Cut_CoinFinds$cf_end_year[index]
  rad.IDs = Cut_CoinFinds$in.radius[index][[1]]
  end_year_list = ID_toget_endyear(rad.IDs)


  is.cf.start.year.same = rep(NULL, length(numCoinsList))
  is.cf.end.year.same = rep(NULL, length(numCoinsList))
  for (o in c(1:length(end_year_list))) {
    
    # testing if start year same within range
     if (is.na(start_year_list[o])) {
      is.cf.start.year.same[o] = NA
      next}
    if (start_year_list[o] <= (start_year+EARLY_DATE) & 
        start_year_list[o] >= (start_year-EARLY_DATE)){
      is.cf.start.year.same[o] = TRUE
    } else {
      is.cf.start.year.same[o] = FALSE  }
    
    # testing if end year same within range
     if (is.na(end_year_list[o])) {
      is.cf.end.year.same[o] = NA
      next}
    if (end_year_list[o] <= (end_year+LATE_DATE) & 
        end_year_list[o] >= (end_year-LATE_DATE)){
      is.cf.end.year.same[o] = TRUE
    } else {
      is.cf.end.year.same[o] = FALSE  }
    
    }

  Cut_CoinFinds$is.cf.start.year.same[index] = I(list(is.cf.start.year.same))
  Cut_CoinFinds$is.cf.end.year.same[index] = I(list(is.cf.end.year.same))

}


```







