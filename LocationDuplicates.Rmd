---
title: "LocationDuplicates"
output: html_document
---

lat = x 
long = y

```{r}
library(dplyr)
library(ggplot2)
library(janitor)
library(tidyr)
library(tidyverse)
library(sf)

```

Read in Data
```{r}
CoinFinds = read.csv("CoinData/CoinFinds.csv")
CoinGroups = read.csv("CoinData/CoinGroups.csv")
```

*** Testing
Check for NAs - none for lat and longitude
```{r}
colSums(is.na(CoinFinds))
```

This code creates the data frame "ClosestNeighbor.CF", which puts the information of the closet geographical neighbor by lattitude and longitude on the same line. The neighboring data's headings have "n." added to them. 

The code is currently set for distance to be in km. Switching which d is used in the code below can change it to degrees.
```{r}
# library(rgeos)
# library(sp)
# library(geosphere)
# 
# GEO_cf = CoinFinds
# coordinates(GEO_cf) = ~cf_custom_y_coordinate+cf_custom_x_coordinate
# 
# #d = gDistance(GEO_cf, byid=T) # distance in km
# d = distm(GEO_cf) # distance in degrees
# 
# min.d <- apply(d, 1, function(x) order(x, decreasing=F)[2])
# 
# ClosestN.CF <- cbind(CoinFinds, CoinFinds[min.d,], apply(d, 1, function(x) sort(x, decreasing=F)[2]))
# 
# colnames(ClosestN.CF) <- c(colnames(CoinFinds), "n.ID", "n.cf_name", "n.cf_place_name", "n.cf_custom_place_name", "n.cf_custom_x_coordinate", "n.cf_custom_y_coordinate", "n.cf_custom_region", "n.cf_custom_region_vague", "n.cf_excavation_name", "n.cf_excavation", "n.cf_excavation_start", "n.cf_excavation_end", "n.cf_single_find", "n.cf_hoard", "n.cf_start_year", "n.cf_end_year", "n.cf_vague", "n.cf_num_coins_found", "n.cf_publication_ref", "n.cf_user", "n.cf_comment", "n.cf_date_entered", "n.Coin.Find.Search", "n.Coin.Find.Json", "n.Exported.at", "distance")
# 
# #Ordering ClosestN.CF by distance
# 
```

Isolating those that have a distance from each other equal to zero
```{r}
# #Ordering ClosestN.CF by distance
# #ClosestN.CF = ClosestN.CF[order(ClosestN.CF$distance),]
# 
# ClosestEqualsZero = ClosestN.CF[ClosestN.CF$distance==0,]
# 
# ClosestEqualsOther = ClosestN.CF[ClosestN.CF$distance>0,]
# 
# OverviewOfEqualZero = data.frame(
#   
#   ID = ClosestEqualsZero$ID,
#   CF = ClosestEqualsZero$cf_name,
#   
#   Neighbor_ID = ClosestEqualsZero$n.ID,
#   Neighboring_CF = ClosestEqualsZero$n.cf_name,
#   
#   Latitude = ClosestEqualsZero$cf_custom_x_coordinate,
#   Longitude = ClosestEqualsZero$cf_custom_y_coordinate,
#   Neighbor_Latitude = ClosestEqualsZero$n.cf_custom_x_coordinate,
#   Neighbor_Longitude = ClosestEqualsZero$n.cf_custom_y_coordinate,
#   
#   distance = ClosestEqualsZero$distance
# 
# )
# 
# 
# OverviewEqualsOther = data.frame(
#   
#   ID = ClosestEqualsOther$ID,
#   CF = ClosestEqualsOther$cf_name,
#   
#   Neighbor_ID = ClosestEqualsOther$n.ID,
#   Neighboring_CF = ClosestEqualsOther$n.cf_name,
#   
#   Latitude = ClosestEqualsOther$cf_custom_x_coordinate,
#   Longitude = ClosestEqualsOther$cf_custom_y_coordinate,
#   Neighbor_Latitude = ClosestEqualsOther$n.cf_custom_x_coordinate,
#   Neighbor_Longitude = ClosestEqualsOther$n.cf_custom_y_coordinate,
#   
#   distance = ClosestEqualsOther$distance
# 
# )
# 
# 
# # I've noticed that for some points, it will list the closet value to it as itself. These points only seem to be those that are already listed as the closest to another point. So I think it's fine if I strip them out?
# 
# # This works for now as a preliminary solution, but I will definetly want to check to see if this correct. 
# # For now, I am stripping out ones that repeat 

```
*****


Radius Method: For each coin find location, return all coin finds within a certain radius. 

Location Filter: For each coin find location, return all coin finds within a certain radius in a list, forming a column of the dataframe CoinFinds
```{r}
#####INPUT####
RADIUS = 1000
##############

cf_nrow = nrow(CoinFinds) - 3000
CoinFinds$in.radius = NA
CoinFinds$num.in.radius = NA

### Using the sf package, creating spatial objects out of each coin find's lat and long points
longitude_list = CoinFinds$cf_custom_y_coordinate
latitude_list = CoinFinds$cf_custom_x_coordinate
IDs_list = CoinFinds$ID
# target point
target <- data_frame(ID = IDs_list, longitude = longitude_list, latitude = latitude_list)
# Specify the source of lat and long coordinates
target_sf <- st_as_sf(target, coords = c("longitude", "latitude"))
st_crs(target_sf) <- 4326

for (i in c(1:cf_nrow)) {
  index = i

  # creating sf spatial object out of the central point in radius
  point_ID = CoinFinds$ID[index]
  point <- data_frame(ID = point_ID, mylon = CoinFinds$cf_custom_y_coordinate[index], mylat = CoinFinds$cf_custom_x_coordinate[index]) 
  point_sf <- st_as_sf(point, coords = c("mylon", "mylat"))
  st_crs(point_sf) <- 4326
  
#  filter records within the RADIUS specified (THE SECTION THAT SLOWS DOWN FOR-LOOP)
  target_sf2 <- target_sf %>%
    mutate(Dist = as.numeric(st_distance(point_sf, target_sf, by_element = TRUE))) %>%
    filter(Dist <= RADIUS)
  
  #adding IDs of coin finds in radius to CoinFinds data frame
  test.target = target_sf2 %>% as_tibble()
  rad.IDs = list(test.target$ID)
  CoinFinds$in.radius[index] = I(rad.IDs)
  CoinFinds$num.in.radius[index] = length(test.target$ID)
}

# filtering on points that only have themselves as closest point. Going forward, this is the data frame that will entries struck from it if they are not of interest. In the end, it will contain only finds that need attention.
Cut_CoinFinds = CoinFinds[CoinFinds$num.in.radius > 1,]

```

NOTES
*at this point, the above code works, it just takes forever to run. Possible solution: 
Some sort of long,lat condition that takes some points out of consideration from the section taking the most time. Still thinking about that...

Quantity Filter 
```{r}
# function that will output number of coins found from an coin find ID
ID_toget_numCoins = function(ID) {
  nums_list <- rep(NULL, length(ID))
  for (i in c(1:length(ID))) {
    row = CoinFinds[CoinFinds$ID==ID[i],][1,]
    nums_list[i] = row$cf_num_coins_found
  }
  return(nums_list)
}
#Cut_CoinFinds = ifelse(Cut_CoinFinds$cf_num_coins_found)

####INPUT#### 
RANGE = 5
#############


# This creates another row in Cut_CoinFinds that returns a list of TRUE/FALSE for each coin find in the radius. TRUE: the number of coins found for a coin find are equal to (+/- a range set by user) the total coins found for the central coin find. FALSE: not the same within a certain range set by user
for (z in c(1:nrow(Cut_CoinFinds))) {
  index = z
  point_ID = Cut_CoinFinds$ID[index]
  point_coins = Cut_CoinFinds$cf_num_coins_found[index]
  rad.IDs = Cut_CoinFinds$in.radius[index][[1]]
  numCoinsList = ID_toget_numCoins(rad.IDs)
  
  # print("Coin ID")
  # print(point_ID)
  # print("Num of Coins for Find")
  # print(numCoinsList)
  # print("IDs of Fines")
  # print(rad.IDs)
  
  are.num.coins.same = rep(NULL, length(numCoinsList))
  for (o in c(1:length(numCoinsList))) {
    if (numCoinsList[o] <= (point_coins+RANGE) & 
        numCoinsList[o] >= (point_coins-RANGE)){
      are.num.coins.same[o] = TRUE
    } else {
      are.num.coins.same[o] = FALSE  }}

  Cut_CoinFinds$are.num.coins.same[index] = I(list(are.num.coins.same))

}


```

NOTES
some coin finds have no coins found. 


Metal Filter
```{r}




```

Excavation Year Filter
```{r}

####INPUT####
START_RANGE = 3
END_RANGE = 3
#############

# insert big for loop

  #start year
  index = z
  point_ID = Cut_CoinFinds$ID[index]
  point_coins = Cut_CoinFinds$cf_excavation_start[index]
  rad.IDs = Cut_CoinFinds$in.radius[index][[1]]
 # numCoinsList = ID_toget_numCoins(rad.IDs) Nee func for excav start year
  
  #end year
  point_ID = Cut_CoinFinds$ID[index]
  point_coins = Cut_CoinFinds$cf_excavation_end[index]
  rad.IDs = Cut_CoinFinds$in.radius[index][[1]]
 # numCoinsList = ID_toget_numCoins(rad.IDs) Nee func for excav end year


  are.excav.start.same = rep(NULL, length(numCoinsList))
  are.excav.end.same = rep(NULL, length(numCoinsList))
  for (o in c(1:length(numCoinsList))) {
    

    #edit this part
    # testing if start year same within range
    if (numCoinsList[o] <= (point_coins+RANGE) & 
        numCoinsList[o] >= (point_coins-RANGE)){
      are.num.coins.same[o] = TRUE
    } else {
      are.num.coins.same[o] = FALSE  }
    
    # testing if end year same within range
    if (numCoinsList[o] <= (point_coins+RANGE) & 
        numCoinsList[o] >= (point_coins-RANGE)){
      are.num.coins.same[o] = TRUE
    } else {
      are.num.coins.same[o] = FALSE  }
    
    }

  Cut_CoinFinds$are.num.coins.same[index] = I(list(are.num.coins.same))

  # END

```















