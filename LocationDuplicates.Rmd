---
title: "LocationDuplicates"
output: html_document
---

lat = x 
long = y

```{r}
library(dplyr)
library(ggplot2)
library(janitor)
library(tidyr)
library(tidyverse)
library(sf)
library(readxl)
```

Read in Data
```{r}
CoinFinds = read.csv("CoinData/CoinFinds.csv")
CoinGroups = read.csv("CoinData/CoinGroups.csv")
Coin_Info = read_excel("CoinData/Coin_Info.xlsx", sheet="Denominations")

Coin_Info$Metal = str_extract(Coin_Info$Name,"(\\w+)")
Coin_Info$Name = gsub("(Gold)","",as.character(Coin_Info$Name))
Coin_Info$Name = gsub("(Silver)","",as.character(Coin_Info$Name))
Coin_Info$Name = gsub("(Bronze)","",as.character(Coin_Info$Name))
Coin_Info$Name = gsub("(Lead)","",as.character(Coin_Info$Name))
Coin_Info$Name = substring(Coin_Info$Name, 4)
```

### What has been dropped
Coin groups where metal is NA

Coin Finds coins = NA or 0
Coin Groups coins = NA or 0


**PREP
Creating a metal column in the CoinGroups dataframe and stripping those that have NA metal 
```{r}

CoinGroups$metal = NA
for (n in c(1:nrow(CoinGroups))) {
  denom_list = c(Coin_Info[['Name']])
  denom_index = match(CoinGroups$DenominationName[n],denom_list, nomatch = 0)
  
  if(denom_index == 0) {
    next
    
  } else {
    metal = Coin_Info$Metal[denom_index]
    CoinGroups$metal[n] = metal
  }
  
}
table(is.na(CoinGroups$metal))
```

Functions
```{r}
# Function for finding excavation start years from IDs
ID_toget_start = function(ID) {
  nums_list <- rep(NULL, length(ID))
  for (i in c(1:length(ID))) {
    row = Cut_CoinFinds[Cut_CoinFinds$ID==ID[i],][1,]
    nums_list[i] = row$cf_excavation_start
  }
  return(nums_list)
}

# Function for finding excavation end years from IDs
ID_toget_end = function(ID) {
  nums_list <- rep(NULL, length(ID))
  for (i in c(1:length(ID))) {
    row = Cut_CoinFinds[Cut_CoinFinds$ID==ID[i],][1,]
    nums_list[i] = row$cf_excavation_end
  }
  return(nums_list)
}
##########

# Function for finding start years from IDs
ID_toget_startyear = function(ID) {
  nums_list <- rep(NULL, length(ID))
  for (i in c(1:length(ID))) {
    row = Cut_CoinFinds[Cut_CoinFinds$ID==ID[i],][1,]
    nums_list[i] = row$cf_start_year
  }
  return(nums_list)
}

# Function for finding start years from IDs
ID_toget_endyear = function(ID) {
  nums_list <- rep(NULL, length(ID))
  for (i in c(1:length(ID))) {
    row = Cut_CoinFinds[Cut_CoinFinds$ID==ID[i],][1,]
    nums_list[i] = row$cf_end_year
  }
  return(nums_list)
}

# function that will output number of coins found from an coin find ID
ID_toget_numCoins = function(ID) {
  nums_list <- rep(NULL, length(ID))
  for (i in c(1:length(ID))) {
    row = CoinFinds[CoinFinds$ID==ID[i],][1,]
    nums_list[i] = row$cf_num_coins_found
  }
  return(nums_list)
}

# function that will output list of coin group IDs from a coin find ID
CF_to_CG = function(cf_IDs) {
  
 # for (i in c(1:length(cf_IDs))) {
    
  row = CoinGroups[CoinGroups$cfID==cf_IDs,]
  nums_list = row$cgID
    
#  }
  return(nums_list)
  
}

```

[FINISH] Filling in NAs in cf_num_coins_found with amounts in CoinGroups
If cf_num_coins_found==NA or 0 still after this reformatting, it gets struck
```{r}

for( i in c(1:nrow(CoinFinds))) {
  
  # using CoinGroups to replace NA values in cf_num_coins_found
  # issue with this, some of the coins in the coin groups are also listed as NA
  #### 10019 still NA because its NA in Coin Groups file, so it was struck
   if(is.na(CoinFinds$cf_num_coins_found[i])) {
     
    CGs = CoinGroups[CoinGroups$cfID==CoinFinds$ID[i],]
    Sum = sum(CGs$cg_num_coins)
    CoinFinds$cf_num_coins_found[i] = Sum
     
   }
  
   if(is.na(CoinFinds$cf_num_coins_found[i])){
     CoinFinds[-i,]
   }
  
}


# taking out rows where cf_num_coins_found is equal to 0 and cg_num_coins_found
CoinFinds = CoinFinds[CoinFinds$cf_num_coins_found != 0 & !is.na(CoinFinds$cf_num_coins_found),]

CoinGroups = CoinGroups[CoinGroups$cg_num_coins != 0 & !is.na(CoinGroups$cg_num_coins),]
CoinGroups = CoinGroups %>% drop_na(metal)
```
**PREP


Location Filter: For each coin find location, return all coin finds within a certain radius in a list, forming a column of the dataframe CoinFinds (DONE)
```{r}
#####INPUT####
RADIUS = 1000
##############

cf_nrow = nrow(CoinFinds) - 1000
CoinFinds$in.radius = NA
CoinFinds$num.in.radius = NA

### Using the sf package, creating spatial objects out of each coin find's lat and long points
longitude_list = CoinFinds$cf_custom_y_coordinate
latitude_list = CoinFinds$cf_custom_x_coordinate
IDs_list = CoinFinds$ID
# target point
target <- data_frame(ID = IDs_list, longitude = longitude_list, latitude = latitude_list)
# Specify the source of lat and long coordinates
target_sf <- st_as_sf(target, coords = c("longitude", "latitude"))
st_crs(target_sf) <- 4326

for (i in c(1:cf_nrow)) {
  index = i

  # creating sf spatial object out of the central point in radius
  point_ID = CoinFinds$ID[index]
  point <- data_frame(ID = point_ID, mylon = CoinFinds$cf_custom_y_coordinate[index], mylat = CoinFinds$cf_custom_x_coordinate[index]) 
  point_sf <- st_as_sf(point, coords = c("mylon", "mylat"))
  st_crs(point_sf) <- 4326
  
  #  filter records within the RADIUS specified (THE SECTION THAT SLOWS DOWN FOR-LOOP)
  target_sf2 <- target_sf %>%
    mutate(Dist = as.numeric(st_distance(point_sf, target_sf, by_element = TRUE))) %>%
    filter(Dist <= RADIUS)
  
  #adding IDs of coin finds in radius to CoinFinds data frame
  test.target = target_sf2 %>% as_tibble()
  rad.IDs = list(test.target$ID)
  CoinFinds$in.radius[index] = I(rad.IDs)
  CoinFinds$num.in.radius[index] = length(test.target$ID)
}


# filtering on points that only have themselves as closest point. Going forward, this is the data frame that will entries struck from it if they are not of interest. In the end, it will contain only finds that need attention.
# Ok on second though, I may just carry through with the whole Data Frame and make cuts at the end
Cut_CoinFinds = CoinFinds

```

Quantity Filter 
```{r}

#cutting it at where the previous for loop stopped
Cut_CoinFinds = Cut_CoinFinds[1:cf_nrow,]

####INPUT#### 
RANGE = 5
#############


# This creates another row in Cut_CoinFinds that returns a list of TRUE/FALSE for each coin find in the radius. TRUE: the number of coins found for a coin find are equal to (+/- a range set by user) the total coins found for the central coin find. FALSE: not the same within a certain range set by user
for (z in c(1:nrow(Cut_CoinFinds))) {
  index = z
  point_ID = Cut_CoinFinds$ID[index]
  point_coins = Cut_CoinFinds$cf_num_coins_found[index]
  rad.IDs = Cut_CoinFinds$in.radius[index][[1]]
  numCoinsList = ID_toget_numCoins(rad.IDs)
  
  are.num.coins.same = rep(NULL, length(numCoinsList))
  for (o in c(1:length(numCoinsList))) {
    
    if (is.na(numCoinsList[o])) {
      are.num.coins.same[o] = NA
      next
    }
    
    if (numCoinsList[o] <= (point_coins+RANGE) & 
        numCoinsList[o] >= (point_coins-RANGE)){
      are.num.coins.same[o] = TRUE
    } else {
      are.num.coins.same[o] = FALSE  }}

  Cut_CoinFinds$are.num.coins.same[index] = I(list(are.num.coins.same))

}


```

NOTES

[FINISH] Metal Filter
```{r}

####INPUT#### for each group of a specific metal, 
RANGE = 1
#############

for (z in c(1:cf_nrow)) {
  index = z
  
  # radius ID info
  point_ID = Cut_CoinFinds$ID[index]
  point_CGs = CoinGroups[CoinGroups$cfID==point_ID,]
  
  point_silver = sum(point_CGs$cg_num_coins[point_CGs$metal=="Silver"])
  point_num_silver = length(point_CGs$cg_num_coins[point_CGs$metal=="Silver"])
  
  point_gold = sum(point_CGs$cg_num_coins[point_CGs$metal=="Gold"])
  point_num_gold = length(point_CGs$cg_num_coins[point_CGs$metal=="Gold"])
  
  point_bronze = sum(point_CGs$cg_num_coins[point_CGs$metal=="Bronze"])
  point_num_bronze = length(point_CGs$cg_num_coins[point_CGs$metal=="Bronze"])
  
  point_lead = sum(point_CGs$cg_num_coins[point_CGs$metal=="Lead"])
  point_num_lead = length(point_CGs$cg_num_coins[point_CGs$metal=="Lead"])
  # need to find metals for the point as well.
  
  #get radius IDs
  rad.IDs = Cut_CoinFinds$in.radius[index][[1]]
  
  CoinGroups$is.silver.same = NA
  CoinGroups$is.gold.same = NA
  CoinGroups$is.bronze.same = NA
  CoinGroups$is.lead.same = NA
  # For each coin find within the main point's radius, which have the same amounts of the same metals (And which metals are the same; create a metal.radius.same column?)?
  
  for (o in c(1:length(rad.IDs))) {
    
    rad_CGs = CoinGroups[CoinGroups$cfID==rad.IDs[o],]
  
    rad_silver = sum(rad_CGs$cg_num_coins[rad_CGs$metal=="Silver"])
    point_num_silver = length(rad_CGs$cg_num_coins[rad_CGs$metal=="Silver"])
    
    rad_gold = sum(rad_CGs$cg_num_coins[rad_CGs$metal=="Gold"])
    point_num_gold = length(rad_CGs$cg_num_coins[rad_CGs$metal=="Gold"])
    
    rad_bronze = sum(rad_CGs$cg_num_coins[rad_CGs$metal=="Bronze"])
    point_num_bronze = length(rad_CGs$cg_num_coins[rad_CGs$metal=="Bronze"])
    
    rad_lead = sum(rad_CGs$cg_num_coins[rad_CGs$metal=="Lead"])
    point_num_lead = length(rad_CGs$cg_num_coins[rad_CGs$metal=="Lead"])

    is.silver.same = rep(NULL, length(rad.IDs))
    is.gold.same = rep(NULL, length(rad.IDs))
    is.bronze.same = rep(NULL, length(rad.IDs))
    is.lead.same = rep(NULL, length(rad.IDs))
    
    # gold
    if((rad_gold <= (point_gold + RANGE) & 
        rad_gold >= (point_gold - RANGE))) {
      is.gold.same[o] = TRUE
    } else {
      is.gold.same[o] = FALSE
    }
    
    # silver 
    if((rad_silver <= (point_silver + RANGE) & 
        rad_silver >= (point_silver - RANGE))) {
      is.silver.same[o] = TRUE
    } else {
      is.silver.same[o] = FALSE
    }
    
    # bronze 
    if((rad_bronze <= (point_bronze + RANGE) & 
        rad_bronze >= (point_bronze - RANGE))) {
      is.bronze.same[o] = TRUE
    } else {
      is.bronze.same[o] = FALSE
    }
    
    # lead 
    if((rad_lead <= (point_lead + RANGE) & 
        rad_lead >= (point_lead - RANGE))) {
        is.lead.same[o] = TRUE
    } else {
      is.lead.same[o] = FALSE
    }
  }
  
  Cut_CoinFinds$is.silver.same[index] = I(list(is.silver.same))
  Cut_CoinFinds$is.gold.same[index] = I(list(is.gold.same))
  Cut_CoinFinds$is.bronze.same[index] = I(list(is.bronze.same))
  Cut_CoinFinds$is.lead.same[index] = I(list(is.lead.same))
}

```


Excavation Year Filter 
```{r}
####INPUT####
START_RANGE = 2
END_RANGE = 2
#############

for (z in c(1:nrow(Cut_CoinFinds))) {
  index = z

  if(is.na(Cut_CoinFinds$cf_excavation_start[index])) {
    next
  }
  if(is.na(Cut_CoinFinds$cf_excavation_end[index])) {
    next
  }
  
  #start year
  point_ID = Cut_CoinFinds$ID[index]
  excav_start = Cut_CoinFinds$cf_excavation_start[index]
  rad.IDs = Cut_CoinFinds$in.radius[index][[1]]
  excav_start_list = ID_toget_start(rad.IDs) 
  
  #end year
  excav_end = Cut_CoinFinds$cf_excavation_end[index]
  rad.IDs = Cut_CoinFinds$in.radius[index][[1]]
  excav_end_list = ID_toget_end(rad.IDs) 


  are.excav.start.same = rep(NULL, length(numCoinsList))
  are.excav.end.same = rep(NULL, length(numCoinsList))
  for (o in c(1:length(excav_end_list))) {
    
    # testing if start year same within range
     if (is.na(excav_start_list[o])) {
      are.num.coins.same[o] = NA
      next}
    if (excav_start_list[o] <= (excav_start+START_RANGE) & 
        excav_start_list[o] >= (excav_start-START_RANGE)){
      are.excav.start.same[o] = TRUE
    } else {
      are.excav.start.same[o] = FALSE  }
    
    # testing if end year same within range
     if (is.na(excav_end_list[o])) {
      are.excav.end.same[o] = NA
      next}
    if (excav_end_list[o] <= (excav_end+END_RANGE) & 
        excav_end_list[o] >= (excav_end-END_RANGE)){
      are.excav.end.same[o] = TRUE
    } else {
      are.excav.end.same[o] = FALSE  }
    
    }

  Cut_CoinFinds$are.excav.start.same[index] = I(list(are.excav.start.same))
  Cut_CoinFinds$are.excav.end.same[index] = I(list(are.excav.end.same))

}

```

Why are some excavation boundaries still put in even though excavation is listed as false. 

Excavation years themselves are NAs. 

if hoard is NA, skip to the next step

Date Range
```{r}
####INPUT####
EARLY_DATE = 10
LATE_DATE = 10
#############

# screening out NAs
for (z in c(1:nrow(Cut_CoinFinds))) {
  index = z

  if(is.na(Cut_CoinFinds$cf_start_year[index])) {
    next
  }
  if(is.na(Cut_CoinFinds$cf_end_year[index])) {
    next
  }
  
  #start year
  point_ID = Cut_CoinFinds$ID[index]
  start_year = Cut_CoinFinds$cf_start_year[index]
  rad.IDs = Cut_CoinFinds$in.radius[index][[1]]
  start_year_list = ID_toget_startyear(rad.IDs) 
  
  #end year
  end_year = Cut_CoinFinds$cf_end_year[index]
  rad.IDs = Cut_CoinFinds$in.radius[index][[1]]
  end_year_list = ID_toget_endyear(rad.IDs)


  is.cf.start.year.same = rep(NULL, length(numCoinsList))
  is.cf.end.year.same = rep(NULL, length(numCoinsList))
  for (o in c(1:length(end_year_list))) {
    
    # testing if start year same within range
     if (is.na(start_year_list[o])) {
      is.cf.start.year.same[o] = NA
      next}
    if (start_year_list[o] <= (start_year+EARLY_DATE) & 
        start_year_list[o] >= (start_year-EARLY_DATE)){
      is.cf.start.year.same[o] = TRUE
    } else {
      is.cf.start.year.same[o] = FALSE  }
    
    # testing if end year same within range
     if (is.na(end_year_list[o])) {
      is.cf.end.year.same[o] = NA
      next}
    if (end_year_list[o] <= (end_year+LATE_DATE) & 
        end_year_list[o] >= (end_year-LATE_DATE)){
      is.cf.end.year.same[o] = TRUE
    } else {
      is.cf.end.year.same[o] = FALSE  }
    
    }

  Cut_CoinFinds$is.cf.start.year.same[index] = I(list(is.cf.start.year.same))
  Cut_CoinFinds$is.cf.end.year.same[index] = I(list(is.cf.end.year.same))

}


```

Data presentation in the end: 






