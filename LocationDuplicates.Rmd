---
title: "LocationDuplicates"
output: html_document
---
ADD:
-AUTHORS
-X NO THS X
-CHRE, user(PeterPhilips), PAS

histogram of dates over number of coins minted per 25 years
-

```{r}
library(dplyr)
library(ggplot2)
library(janitor)
library(tidyr)
library(tidyverse)
library(sf)
library(readxl)
library(writexl)
library(multicon)

library(ks)
```

Read in Data (Download Date: )
```{r}
CoinFinds = read.csv("CoinFinds.csv")
CoinGroups = read.csv("CoinGroups.csv")
Coin_Info = read_excel("Coin_info.xlsx", sheet="Denominations")

# # Disconsidered Coin Find excel sheet labeled Not_A_Duplicate.xlsx
disconsidered = read_excel("Not_A_Duplicate.xlsx")
old_VerDupes = read_excel("VerifyDuplicates.xlsx")

```

Coin_Info has the information about which metal corresponds to each denomination. 
Here, I am formatting it so I can use it in the next section. 
```{r}
Coin_Info$Metal = str_extract(Coin_Info$Name,"(\\w+)")
Coin_Info$Name = gsub("(Gold)","",as.character(Coin_Info$Name))
Coin_Info$Name = gsub("(Silver)","",as.character(Coin_Info$Name))
Coin_Info$Name = gsub("(Bronze)","",as.character(Coin_Info$Name))
Coin_Info$Name = gsub("(Lead)","",as.character(Coin_Info$Name))
Coin_Info$Name = substring(Coin_Info$Name, 4)
```

Creating a metal column in the CoinGroups dataframe using the information from Coin_Info
```{r}

CoinGroups$metal = NA
for (n in c(1:nrow(CoinGroups))) {
  
  #finding the index of the denomination in Coin_Info that corresponds with the Coin Group
  denom_list = c(Coin_Info[['Name']])
  denom_index = match(CoinGroups$DenominationName[n], denom_list, nomatch = 0)
  
  # inputting the metal that corresponds with the denomination of each coin group
  # skipping if the Coin Group does not have a metal listed
  if(denom_index == 0) {
    next
    
  } else {
    metal = Coin_Info$Metal[denom_index]
    CoinGroups$metal[n] = metal
  }
  
}
```

Functions
```{r}
# Function for finding excavation start years from a list of cfIDs
ID_toget_start = function(ID) {
  nums_list <- rep(NULL, length(ID))
  for (i in c(1:length(ID))) {
    row = Cut_CoinFinds[Cut_CoinFinds$ID==ID[i],][1,]
    nums_list[i] = row$cf_excavation_start
  }
  return(nums_list)
}

# Function for finding excavation end years from a list of cfIDs
ID_toget_end = function(ID) {
  nums_list <- rep(NULL, length(ID))
  for (i in c(1:length(ID))) {
    row = Cut_CoinFinds[Cut_CoinFinds$ID==ID[i],][1,]
    nums_list[i] = row$cf_excavation_end
  }
  return(nums_list)
}
##########

# Function for finding start years from a list of cfIDs
ID_toget_startyear = function(ID) {
  nums_list <- rep(NULL, length(ID))
  for (i in c(1:length(ID))) {
    row = Cut_CoinFinds[Cut_CoinFinds$ID==ID[i],][1,]
    nums_list[i] = row$cf_start_year
  }
  return(nums_list)
}

# Function for finding end years from a list of cfIDs
ID_toget_endyear = function(ID) {
  nums_list <- rep(NULL, length(ID))
  for (i in c(1:length(ID))) {
    row = Cut_CoinFinds[Cut_CoinFinds$ID==ID[i],][1,]
    nums_list[i] = row$cf_end_year
  }
  return(nums_list)
}

########
# function that will output the number of coins found from a cfID
ID_toget_numCoins = function(ID) {
  nums_list <- rep(NULL, length(ID))
  for (i in c(1:length(ID))) {
    row = CoinFinds[CoinFinds$ID==ID[i],][1,]
    nums_list[i] = row$cf_num_coins_found
  }
  return(nums_list)
}

# function that will output list of coin group IDs from a coin find ID
CF_to_CG = function(cf_IDs) {
  row = CoinGroups[CoinGroups$cfID==cf_IDs,]
  nums_list = row$cgID
  
  return(nums_list)
}



```


PROCESSING
(ONE A) 
Filling in NAs in cf_num_coins_found with amounts in CoinGroups dataframe (though some coin amounts in CoinGroups are also NA).
A few categories of coin groups and coin finds get struck:
- If cf_num_coins_found==NA or 0 after this reformatting
- cg_num_coins_found==NA or 0 still after this reformatting
    *NOTE = if this operation is done there are no longer coin groups listed with a coin find in the CG dataframe, these coin finds are excised from the dataframe (amounts to 60)
- Coin Groups where metal == NA
-everything with THS in the name
```{r}

for( i in c(1:nrow(CoinFinds))) {
   if(is.na(CoinFinds$cf_num_coins_found[i])) {
     
    # summing up coin amounts from each coin group in the coin find 
    CGs = CoinGroups[CoinGroups$cfID==CoinFinds$ID[i],]
    Sum = sum(CGs$cg_num_coins)
    CoinFinds$cf_num_coins_found[i] = Sum
   }
  
  #striking coin finds that still have NA for cf_num_coins_found
   if(is.na(CoinFinds$cf_num_coins_found[i])){
     CoinFinds[-i,]
   }
  
}

# taking out rows where cf_num_coins_found is equal to 0 and cg_num_coins_found is 0
CoinFinds = CoinFinds[CoinFinds$cf_num_coins_found != 0 & !is.na(CoinFinds$cf_num_coins_found),]

# taking out rows where cg_num_coins_found is equal to 0 and cg_num_coins_found
CoinGroups = CoinGroups[CoinGroups$cg_num_coins != 0 & !is.na(CoinGroups$cg_num_coins),]

# taking out coin groups where metal == NA
CoinGroups = CoinGroups %>% drop_na(metal)

#taking out everything with THS
CoinFinds = CoinFinds[!grepl("THS-", CoinFinds$cf_name),]
CoinGroups = CoinGroups[!grepl("THS-", CoinGroups$cf_name),]
```

(ONE B)
```{r}

# Reconstruct the total number of coins by summing up the silver, gold, bronze, and lead across a coin find's coin groups
# Reconstruct start and end dates from the lowest and highest respectively of dates listed among a cf's cgs. 
CoinFinds$total.gold = NA
CoinFinds$total.silver = NA
CoinFinds$total.bronze = NA
CoinFinds$total.lead = NA
for (z in c(1:cf_nrow)) {
  index = z
  
  # get the cgIDs corresponding to central cf
  point_ID = CoinFinds$ID[index]
  point_CGs = CoinGroups[CoinGroups$cfID==point_ID,]
  
  #sum up amount of coins of each metal for a coin find
  point_silver = sum(point_CGs$cg_num_coins[point_CGs$metal=="Silver"])
  point_gold = sum(point_CGs$cg_num_coins[point_CGs$metal=="Gold"])
  point_bronze = sum(point_CGs$cg_num_coins[point_CGs$metal=="Bronze"])
  point_lead = sum(point_CGs$cg_num_coins[point_CGs$metal=="Lead"])
 
  CoinFinds$total.gold[index] = point_gold
  CoinFinds$total.silver[index] = point_silver
  CoinFinds$total.bronze[index] = point_bronze
  CoinFinds$total.lead[index] = point_lead
  CoinFinds$cf_num_coins_found[index] = point_gold + point_silver + point_bronze + point_lead 
  
  #This will throw up an error about infinity, but I'm cutting out those coin finds in a few lines
  best_start_date = min(point_CGs$cg_start_year)
  best_end_date = max(point_CGs$cg_end_year)
  
  CoinFinds$cf_start_year[index] = best_start_date
  CoinFinds$cf_end_year[index] = best_end_date }

#Taking out coin finds that no longer have coin groups associated with them
CoinFinds = CoinFinds[CoinFinds$cf_num_coins_found!=0,]

```


(TWO)
Location Filter: For each coin find location, return all coin finds within a certain radius (that you input) in a list, forming a column of CoinFinds
```{r}
#####INPUT RADIUS IN KM####
RADIUS = 1
##############

cf_nrow = nrow(CoinFinds) 
CoinFinds$in.radius = NA
CoinFinds$num.in.radius = NA

# Using the sf package, creating spatial objects out of each coin find's lat and long points
longitude_list = CoinFinds$cf_custom_y_coordinate
latitude_list = CoinFinds$cf_custom_x_coordinate
IDs_list = CoinFinds$ID
target <- data_frame(ID = IDs_list, longitude = longitude_list, latitude = latitude_list)
target_sf <- st_as_sf(target, coords = c("longitude", "latitude"))
st_crs(target_sf) <- 4326

for (i in c(1:cf_nrow)) {
  index = i

  # creating sf spatial object out of the central point in radius
  point_ID = CoinFinds$ID[index]
  point <- data_frame(ID = point_ID, mylon = CoinFinds$cf_custom_y_coordinate[index], mylat = CoinFinds$cf_custom_x_coordinate[index]) 
  point_sf <- st_as_sf(point, coords = c("mylon", "mylat"))
  st_crs(point_sf) <- 4326
  
  #  filter records within the RADIUS specified
  target_sf2 <- target_sf %>%
    #compare between the point and target to see if they are a duplicate?
    mutate(Dist = as.numeric(st_distance(point_sf, target_sf, by_element = TRUE))) %>%
    filter(Dist <= RADIUS)
  
  #adding IDs of coin finds in radius to CoinFinds data frame
  test.target = target_sf2 %>% as_tibble()
  rad.IDs = list(test.target$ID)
  CoinFinds$in.radius[index] = I(rad.IDs)
  CoinFinds$num.in.radius[index] = length(test.target$ID)
}


# Originally, I was going to take coin finds out that had no other finds in their radius but I decided not to. 
# But I already ended up using Cut_CoinFinds as a variable name below, so I just keep it here. 
Cut_CoinFinds = CoinFinds

```

(THREE)
Quantity Filter: compares cf_num_coins_found between the central point and the radius points. Creates a column of TRUE/FALSES in Cut_CoinFinds indicating whether the radius point is the same or different (within a range you input) from the central point. 
I also calculate the difference between the amount of coins of the central find and that of each radius find. This forms another column of lists. 
```{r}

####INPUT#### 
RANGE = 5
#############


# This creates another row in Cut_CoinFinds that returns a list of TRUE/FALSE for each coin find in the radius. TRUE: the number of coins found for a coin find are equal to (+/- a range set by user) the total coins found for the central coin find. FALSE: not the same within a certain range set by user
for (z in c(1:cf_nrow)) {
  
  #finding the number of coins found for the central coin find and the radius coin finds
  index = z
  point_ID = Cut_CoinFinds$ID[index]
  point_coins = Cut_CoinFinds$cf_num_coins_found[index]
  rad.IDs = Cut_CoinFinds$in.radius[index][[1]]
  numCoinsList = ID_toget_numCoins(rad.IDs)
  
  # creating a TRUE/FALSE list through testing whether radius coin amounts == central coin amount (within a tolerance)
  are.num.coins.same = rep(NULL, length(numCoinsList))
  dif.num.coins = rep(NULL, length(numCoinsList))
  for (o in c(1:length(numCoinsList))) {
    
    if (is.na(numCoinsList[o])) {
      are.num.coins.same[o] = NA
      dif.num.coins[o] = NA
      next
    }
    
    if (numCoinsList[o] <= (point_coins+RANGE) & 
        numCoinsList[o] >= (point_coins-RANGE)){
      are.num.coins.same[o] = TRUE
      dif.num.coins[o] = point_coins - numCoinsList[o]
      
    } else {
      are.num.coins.same[o] = FALSE
      dif.num.coins[o] = NA
      dif.num.coins[o] = point_coins - numCoinsList[o] }}

  # add TRUE/FALSE list to Cut_CoinFinds
  Cut_CoinFinds$are.num.coins.same[index] = I(list(are.num.coins.same))
  Cut_CoinFinds$dif.num.coins[index] = I(list(dif.num.coins))
}


```

(FOUR)
Metal Filter: Uses amount of each metal in a coin find and compares this between the central coin find and the radius coin finds. Generates TRUE/FALSE list like above that's added to Cut_CoinFinds. Also generates columns of the difference in metal amounts between the central coin find and each radius coin find.
```{r}

# creating columns for each metal type in Cut_CoinFinds
Cut_CoinFinds$is.silver.same = NA
Cut_CoinFinds$dif.silver = NA

Cut_CoinFinds$is.gold.same = NA
Cut_CoinFinds$dif.gold = NA

Cut_CoinFinds$is.bronze.same = NA
Cut_CoinFinds$dif.bronze = NA

Cut_CoinFinds$is.lead.same = NA
Cut_CoinFinds$dif.lead = NA

for (z in c(1:cf_nrow)) {
  index = z
  
  # get the cgIDs corresponding to central cf
  point_ID = Cut_CoinFinds$ID[index]
  point_CGs = CoinGroups[CoinGroups$cfID==point_ID,]
  
  #sum up amount of coins of each metal for a coin find
  point_silver = sum(point_CGs$cg_num_coins[point_CGs$metal=="Silver"])
  point_num_silver = length(point_CGs$cg_num_coins[point_CGs$metal=="Silver"])
  
  point_gold = sum(point_CGs$cg_num_coins[point_CGs$metal=="Gold"])
  point_num_gold = length(point_CGs$cg_num_coins[point_CGs$metal=="Gold"])
  
  point_bronze = sum(point_CGs$cg_num_coins[point_CGs$metal=="Bronze"])
  point_num_bronze = length(point_CGs$cg_num_coins[point_CGs$metal=="Bronze"])
  
  point_lead = sum(point_CGs$cg_num_coins[point_CGs$metal=="Lead"])
  point_num_lead = length(point_CGs$cg_num_coins[point_CGs$metal=="Lead"])
 
  #get radius IDs
  rad.IDs = Cut_CoinFinds$in.radius[index][[1]]
  
  # create empty lists which will be filled in for loop
  is.silver.same = rep(NULL, length(rad.IDs))
  is.gold.same = rep(NULL, length(rad.IDs))
  is.bronze.same = rep(NULL, length(rad.IDs))
  is.lead.same = rep(NULL, length(rad.IDs))  
  
  dif.lead = rep(NULL, length(rad.IDs)) 
  dif.silver = rep(NULL, length(rad.IDs)) 
  dif.gold = rep(NULL, length(rad.IDs)) 
  dif.bronze = rep(NULL, length(rad.IDs)) 
  
  # loops through each cf in the radius of the central cf. 
  # Compares amount of each metal in cf between the central and radius points
  # outputs TRUE/FALSE lists and total amounts of each metal in a coin find
  for (o in c(1:length(rad.IDs))) {
    
    # coin groups for each radius point
    rad_CGs = CoinGroups[CoinGroups$cfID==rad.IDs[o],]
  
    # summing up amount of each metal in cf
    rad_silver = sum(rad_CGs$cg_num_coins[rad_CGs$metal=="Silver"])
    
    rad_gold = sum(rad_CGs$cg_num_coins[rad_CGs$metal=="Gold"])
    
    rad_bronze = sum(rad_CGs$cg_num_coins[rad_CGs$metal=="Bronze"])
    
    rad_lead = sum(rad_CGs$cg_num_coins[rad_CGs$metal=="Lead"])

    #save total metal amounts
    
    dif.gold[o] = point_gold - rad_gold
    dif.silver[o] = point_silver - rad_silver
    dif.bronze[o] = point_bronze - rad_bronze
    dif.lead[o] = point_lead - rad_lead
    
    # comparing amount of gold
    if((rad_gold <= (point_gold + point_num_gold) & 
        rad_gold >= (point_gold - point_num_gold))) {
      is.gold.same[o] = TRUE
      
    } else {
      is.gold.same[o] = FALSE }
    
    # silver 
    if((rad_silver <= (point_silver + point_num_silver) & 
        rad_silver >= (point_silver - point_num_silver))) {
      is.silver.same[o] = TRUE
      
    } else {
      is.silver.same[o] = FALSE}
    
    # bronze 
    if((rad_bronze <= (point_bronze + point_num_bronze) & 
        rad_bronze >= (point_bronze - point_num_bronze))) {
      is.bronze.same[o] = TRUE
    } else {
      is.bronze.same[o] = FALSE  }
    
    # lead 
    if((rad_lead <= (point_lead + point_num_lead) & 
        rad_lead >= (point_lead - point_num_lead))) {
        is.lead.same[o] = TRUE
    } else {
      is.lead.same[o] = FALSE }
  }
  
  # add lists to Cut_CoinFinds
  Cut_CoinFinds$is.silver.same[index] = I(list(is.silver.same))
  Cut_CoinFinds$is.gold.same[index] = I(list(is.gold.same))
  Cut_CoinFinds$is.bronze.same[index] = I(list(is.bronze.same))
  Cut_CoinFinds$is.lead.same[index] = I(list(is.lead.same))
  
  Cut_CoinFinds$dif.silver[index] = I(list(dif.silver))
  Cut_CoinFinds$dif.gold[index] = I(list(dif.gold))
  Cut_CoinFinds$dif.bronze[index] = I(list(dif.bronze))
  Cut_CoinFinds$dif.lead[index] = I(list(dif.lead))
}

```

(FIVE)
Excavation Year Filter: does the same comparison but with cf_excavation_start and cf_excavation_end
```{r}
####INPUT####
START_RANGE = 2
END_RANGE = 2
#############

Cut_CoinFinds$are.excav.start.same = NA
Cut_CoinFinds$are.excav.end.same = NA
Cut_CoinFinds$exstart.date.dif = NA
Cut_CoinFinds$exend.date.dif = NA

for (z in c(1:cf_nrow)) {
  index = z

  if(is.na(Cut_CoinFinds$cf_excavation_start[index])) {
    next
  }
  if(is.na(Cut_CoinFinds$cf_excavation_end[index])) {
    next
  }
  
  #start year
  point_ID = Cut_CoinFinds$ID[index]
  excav_start = Cut_CoinFinds$cf_excavation_start[index]
  rad.IDs = Cut_CoinFinds$in.radius[index][[1]]
  excav_start_list = ID_toget_start(rad.IDs) 
  
  #end year
  excav_end = Cut_CoinFinds$cf_excavation_end[index]
  rad.IDs = Cut_CoinFinds$in.radius[index][[1]]
  excav_end_list = ID_toget_end(rad.IDs) 

  are.excav.start.same = rep(NULL, length(numCoinsList))
  are.excav.end.same = rep(NULL, length(numCoinsList))
  exstart.date.dif = rep(NULL, length(numCoinsList))
  exend.date.dif = rep(NULL, length(numCoinsList))
  for (o in c(1:length(excav_end_list))) {
    
    # testing if start year same within range
     if (is.na(excav_start_list[o])) {
      are.excav.start.same[o] = NA
      exstart.date.dif[o] = NA
      }
    else if (excav_start_list[o] <= (excav_start+START_RANGE) & excav_start_list[o] >= (excav_start-START_RANGE)) {
      are.excav.start.same[o] = TRUE
      exstart.date.dif[o] = excav_start - excav_start_list[o]
      } 
    else {
      are.excav.start.same[o] = FALSE 
      exstart.date.dif[o] = excav_start - excav_start_list[o]}
    
    # testing if end year same within range
     if (is.na(excav_end_list[o])) {
      are.excav.end.same[o] = NA
      exend.date.dif[o] = NA
      }
    else if (excav_end_list[o] <= (excav_end+END_RANGE) & excav_end_list[o] >= (excav_end-END_RANGE)) {
      are.excav.end.same[o] = TRUE
      exend.date.dif[o] = excav_end - excav_end_list[o]
      } 
    else {
      are.excav.end.same[o] = FALSE
      exend.date.dif[o] = excav_end - excav_end_list[o]}
    
    }

  Cut_CoinFinds$are.excav.start.same[index] = I(list(are.excav.start.same))
  Cut_CoinFinds$are.excav.end.same[index] = I(list(are.excav.end.same))
  
  Cut_CoinFinds$exstart.date.dif[index] = I(list(exstart.date.dif))
  Cut_CoinFinds$exend.date.dif[index] = I(list(exend.date.dif))
}

```

(SIX)
Date Range: does the same comparison but with cf_start_year and cf_end_year
```{r}
####INPUT####
EARLY_DATE = 25
LATE_DATE = 25
#############

Cut_CoinFinds$is.cf.start.year.same = NA
Cut_CoinFinds$is.cf.end.year.same = NA
Cut_CoinFinds$start.date.dif = NA
Cut_CoinFinds$end.date.dif = NA

# screening out NAs
for (z in c(1:nrow(Cut_CoinFinds))) {
  index = z

  if(is.na(Cut_CoinFinds$cf_start_year[index])) {
    next
  }
  if(is.na(Cut_CoinFinds$cf_end_year[index])) {
    next
  }
  
  #start year
  point_ID = Cut_CoinFinds$ID[index]
  start_year = Cut_CoinFinds$cf_start_year[index]
  rad.IDs = Cut_CoinFinds$in.radius[index][[1]]
  start_year_list = ID_toget_startyear(rad.IDs) 
  
  #end year
  end_year = Cut_CoinFinds$cf_end_year[index]
  rad.IDs = Cut_CoinFinds$in.radius[index][[1]]
  end_year_list = ID_toget_endyear(rad.IDs)


  is.cf.start.year.same = rep(NULL, length(numCoinsList))
  is.cf.end.year.same = rep(NULL, length(numCoinsList))
  start.date.dif = rep(NULL, length(numCoinsList))
  end.date.dif = rep(NULL, length(numCoinsList))
  
  for (o in c(1:length(end_year_list))) {
    
    # testing if start year same within range
    if (is.na(start_year_list[o])) {
      is.cf.start.year.same[o] = NA 
      start.date.dif[o] = NA
      
    }else if (start_year_list[o] <= (start_year+EARLY_DATE) & start_year_list[o] >= (start_year-EARLY_DATE)){
      is.cf.start.year.same[o] = TRUE
      start.date.dif[o] = start_year - start_year_list[o]
    } else {
      is.cf.start.year.same[o] = FALSE
      start.date.dif[o] = start_year - start_year_list[o]}
    
    # testing if end year same within range
     if (is.na(end_year_list[o])) {
      is.cf.end.year.same[o] = NA
      end.date.dif[o] = NA
      
    } else if (end_year_list[o] <= (end_year+LATE_DATE) & end_year_list[o] >= (end_year-LATE_DATE)){
      is.cf.end.year.same[o] = TRUE
      end.date.dif[o] = end_year - end_year_list[o]
      
    } else {
      is.cf.end.year.same[o] = FALSE 
      end.date.dif[o] = end_year - end_year_list[o]}
    
    }

  Cut_CoinFinds$is.cf.start.year.same[index] = I(list(is.cf.start.year.same))
  Cut_CoinFinds$is.cf.end.year.same[index] = I(list(is.cf.end.year.same))
  Cut_CoinFinds$start.date.dif[index] = I(list(start.date.dif))
  Cut_CoinFinds$end.date.dif[index] = I(list(end.date.dif))
}


```
#########

(SEVEN)
Cut out finds with no other finds in their radius. 
```{r}
# create new dataframe of possible duplicates to test
TEST_CoinFinds = Cut_CoinFinds

# creating a column that flags whether a central cf has only one cf in its radius
# (The location filter will place a point within its own radius, so if a cf has only one other cf in its radius, they are the same)
TEST_CoinFinds$one.in.radius = NA
for (i in c(1:cf_nrow)) {
  
  length = length(TEST_CoinFinds$in.radius[i][[1]])
  if (length==1) {
    TEST_CoinFinds$one.in.radius[i] = TRUE
  }else{
    TEST_CoinFinds$one.in.radius[i] = FALSE
  }
}

# this is the data frame of CFs that can't be duplicates
disconsidered_CFs = TEST_CoinFinds[TEST_CoinFinds$one.in.radius==TRUE,]

# this is the data fram of coin finds that could be duplicates
TEST_CoinFinds = TEST_CoinFinds[TEST_CoinFinds$one.in.radius==FALSE,]

```

(EIGHT)
Create clusterID out of coin find IDs separated by periods that comprise a geographical cluster 
```{r}

TEST_CoinFinds$clusterID = NA
# creating clusterID and putting it in the main data frame
for (i in c(1:nrow(TEST_CoinFinds))) {
  
  radius_list = TEST_CoinFinds$in.radius[i][[1]]
  clusterID = paste(radius_list, collapse = ".")
  
  TEST_CoinFinds$clusterID[i] = clusterID
}

```

(NINE)
FULL_clusters = dataframe with clusterID, cfID of the central cf, name of central coin find
(This dataframe will have duplicates of clusterIDs)
```{r}
FULL_clusters = data.frame(cfID = TEST_CoinFinds$ID, 
                           name = TEST_CoinFinds$cf_name, 
                           author = TEST_CoinFinds$cf_user, 
                           clusterID = TEST_CoinFinds$clusterID, 
                           total.gold = TEST_CoinFinds$total.gold,
                           total.silver = TEST_CoinFinds$total.silver,
                           total.bronze = TEST_CoinFinds$total.bronze,
                           total.lead = TEST_CoinFinds$total.lead,
                           
                           total.coins = TEST_CoinFinds$cf_num_coins_found,
                           start.year = TEST_CoinFinds$cf_start_year,
                           end.year = TEST_CoinFinds$cf_end_year,
                           excav.start = TEST_CoinFinds$cf_excavation_start,
                           excav.end = TEST_CoinFinds$cf_excavation_end)
FULL_clusters$radius = rep(RADIUS, nrow(FULL_clusters))
```

(TEN)
Adding extra columns to FULL_clusters
for number of coins, start and end date, and metals I have a column for percent matches in each cluster 
and the avg of difference between the central coin find and the cluster value for the above attributes
```{r}
## Creating extra columns
FULL_clusters$percent.num.coins.same = NA
FULL_clusters$avg.coin.num.dif = NA

FULL_clusters$percent.start.date.same = NA
FULL_clusters$avg.start.date.dif = NA

FULL_clusters$percent.end.date.same = NA
FULL_clusters$avg.end.date.dif = NA

#################
## Excav start and ends
FULL_clusters$percent.exstart.same = NA
FULL_clusters$avg.exstart.dif = NA

FULL_clusters$percent.exend.same = NA
FULL_clusters$avg.exend.dif = NA
#################

#metals
FULL_clusters$percent.silver.same = NA
FULL_clusters$avg.silver.dif = NA

FULL_clusters$percent.gold.same = NA
FULL_clusters$avg.gold.dif = NA

FULL_clusters$percent.bronze.same = NA
FULL_clusters$avg.bronze.dif = NA

FULL_clusters$percent.lead.same = NA
FULL_clusters$avg.lead.dif = NA

#num coins
for (i in c(1:nrow(FULL_clusters))) {
  index = i
  FULL_id = FULL_clusters$cfID[index]
  FULL_FULL = Cut_CoinFinds[Cut_CoinFinds$ID == FULL_id,]
  num.coins = unlist(FULL_FULL$are.num.coins.same[1][1])
  coin.difs = unlist(FULL_FULL$dif.num.coins[1][1])
  
  FULL_clusters$percent.num.coins.same[index] = ((length(num.coins[num.coins==TRUE])-1)/FULL_FULL$num.in.radius)*100
  
  FULL_clusters$avg.coin.num.dif[i] = sum(coin.difs)/(length(coin.difs)-1)
}

### COIN DATE RANGES
#start date range
for (i in c(1:nrow(FULL_clusters))) {
  index = i
  FULL_id = FULL_clusters$cfID[index]
  FULL_FULL = Cut_CoinFinds[Cut_CoinFinds$ID == FULL_id,]
  
  num.starts = unlist(FULL_FULL$is.cf.start.year.same[1][1])
  start.date.difs = unlist(FULL_FULL$start.date.di[1][1])
  
  FULL_clusters$percent.start.date.same[index] = ((length(num.starts[num.starts==TRUE])-1)/FULL_FULL$num.in.radius)*100
  FULL_clusters$avg.start.date.dif[i] = sum(start.date.difs)/(length(start.date.difs)-1)
  
  num.ends = unlist(FULL_FULL$is.cf.end.year.same[1][1])
  end.date.difs = unlist(FULL_FULL$end.date.dif[1][1])
  
  FULL_clusters$percent.end.date.same[index] = ((length(num.ends[num.ends==TRUE])-1)/FULL_FULL$num.in.radius)*100
  FULL_clusters$avg.end.date.dif[i] = sum(end.date.difs)/(length(end.date.difs)-1)
  
}


### EXCAVATIONS
for (i in c(1:nrow(FULL_clusters))) {
  index = i
  FULL_id = FULL_clusters$cfID[index]
  FULL_FULL = Cut_CoinFinds[Cut_CoinFinds$ID == FULL_id,]

  num.starts = unlist(FULL_FULL$are.excav.start.same[1][1])
  exstart.date.difs = unlist(FULL_FULL$exstart.date.dif[1][1])

  FULL_clusters$percent.exstart.same[index] = ((length(num.starts[num.starts==TRUE])-1)/FULL_FULL$num.in.radius)*100
  FULL_clusters$avg.exstart.dif[i] = sum(exstart.date.difs)/(length(exstart.date.difs)-1)

  num.ends = unlist(FULL_FULL$are.excav.end.same[1][1])
  exend.date.difs = unlist(FULL_FULL$exend.date.dif[1][1])

  FULL_clusters$percent.exend.same[index] = ((length(num.ends[num.ends==TRUE])-1)/FULL_FULL$num.in.radius)*100
  FULL_clusters$avg.exend.dif[i] = sum(exend.date.difs)/(length(exend.date.difs)-1)

}


###METALS
for (i in c(1:nrow(FULL_clusters))) {
  index = i
  FULL_id = FULL_clusters$cfID[index]
  FULL_FULL = Cut_CoinFinds[Cut_CoinFinds$ID == FULL_id,]
  
  num.silver = unlist(FULL_FULL$is.silver.same[1][1])
  num.gold = unlist(FULL_FULL$is.gold.same[1][1])
  num.lead = unlist(FULL_FULL$is.lead.same[1][1])
  num.bronze = unlist(FULL_FULL$is.bronze.same[1][1])
  
  silver.difs = unlist(FULL_FULL$dif.silver[1][1])
  gold.difs = unlist(FULL_FULL$dif.gold[1][1])
  lead.difs = unlist(FULL_FULL$dif.lead[1][1])
  bronze.difs = unlist(FULL_FULL$dif.bronze[1][1])

  FULL_clusters$percent.silver.same[index] = (length(num.silver[num.silver==TRUE])/FULL_FULL$num.in.radius)*100
  FULL_clusters$percent.gold.same[index] = (length(num.gold[num.gold==TRUE])/FULL_FULL$num.in.radius)*100
  FULL_clusters$percent.bronze.same[index] = (length(num.bronze[num.bronze==TRUE])/FULL_FULL$num.in.radius)*100
  FULL_clusters$percent.lead.same[index] = (length(num.lead[num.lead==TRUE])/FULL_FULL$num.in.radius)*100
  
  FULL_clusters$avg.silver.dif[i] = sum(silver.difs)/(length(silver.difs)-1)
  FULL_clusters$avg.gold.dif[i] = sum(gold.difs)/(length(gold.difs)-1)
  FULL_clusters$avg.bronze.dif[i] = sum(bronze.difs)/(length(bronze.difs)-1)
  FULL_clusters$avg.lead.dif[i] = sum(lead.difs)/(length(lead.difs)-1)

}

```

(ELEVEN)
Reorder columns for easy viewing
```{r}
col_order <- c("cfID", "name", "author", "clusterID", "radius",
               "total.gold", "avg.gold.dif", "percent.gold.same", 
               "total.silver", "avg.silver.dif", "percent.silver.same", 
               "total.bronze", "avg.bronze.dif", "percent.bronze.same", 
               "total.lead", "avg.lead.dif", "percent.lead.same", 
               "start.year", "avg.start.date.dif", "percent.start.date.same",
               "end.year", "avg.end.date.dif", "percent.end.date.same",
               "excav.start", "avg.exstart.dif", "percent.exstart.same",
               "excav.end", "avg.exend.dif", "percent.exend.same")
FULL_clusters <- FULL_clusters[, col_order]
```


(TWELVE)
Match Score
-silver
-gold
-bronze
- start and end year 
G, S, B, SD, ED, EXS, EXE
```{r message=TRUE}

Verify_Dupes = data.frame(
  central_cf = NA,
  central_name = NA,
  radius_cf = NA,
  radius_name = NA
)


verID = 1
for (i in c(1:nrow(FULL_clusters))) {
  full = i
  Verify_Dupes$central_cf[verID] = FULL_clusters$cfID[full]
  cluster.list = strsplit(FULL_clusters$clusterID[full], ".", fixed=T)
  rows = length(cluster.list[[1]])
  
  new = data.frame(central_cf = rep(NA, rows), central_name = rep(NA, rows), radius_cf = rep(NA, rows), radius_name = rep(NA, rows))
  
  Verify_Dupes = rbind(Verify_Dupes, new)

  verID = verID + rows
  
}

verID = 1
for (i in c(1:nrow(FULL_clusters))) {
  full = i
  
  cluster.list = strsplit(FULL_clusters$clusterID[full], ".", fixed=T)
  rows = length(cluster.list[[1]])
  
  key = Verify_Dupes$central_cf[verID]
  Verify_Dupes$radius_cf[verID] = cluster.list[[1]][1]
  
  for(cent in c(1:rows)){
    Verify_Dupes$central_cf[(cent+verID)-1] = key
    if (cent>1){ 
      Verify_Dupes$radius_cf[(cent+verID)-1] = cluster.list[[1]][cent]
    
    }
  }
  
  verID = verID + rows
}

Verify_Dupes = Verify_Dupes[1:(nrow(Verify_Dupes)-1),]

Verify_Dupes$G = NA
Verify_Dupes$S = NA
Verify_Dupes$B = NA
Verify_Dupes$SD = NA
Verify_Dupes$ED = NA
Verify_Dupes$EXS = NA
Verify_Dupes$EXE = NA

# Fill in true and falses 
for (i in c(1:nrow(Verify_Dupes))) {
  index = i
  
  central_info = Cut_CoinFinds[Cut_CoinFinds$ID==Verify_Dupes$central_cf[index],]
  radius = Verify_Dupes$radius_cf[index]
  radius_index = which(c(central_info$in.radius[[1]]) == as.integer(radius))
  
  Verify_Dupes$G[index] = central_info$is.gold.same[1][[1]][radius_index]
  Verify_Dupes$S[index] = central_info$is.silver.same[1][[1]][radius_index]
  Verify_Dupes$B[index] = central_info$is.bronze.same[1][[1]][radius_index]
  Verify_Dupes$SD[index] = central_info$is.cf.start.year.same[1][[1]][radius_index]
  Verify_Dupes$ED[index] = central_info$is.cf.end.year.same[1][[1]][radius_index]
  Verify_Dupes$EXS[index] = central_info$are.excav.start.same[1][[1]][radius_index]
  Verify_Dupes$EXE[index] = central_info$are.excav.end.same[1][[1]][radius_index]
}

#convert trues and falses into integers
Verify_Dupes$G = as.integer(Verify_Dupes$G)
Verify_Dupes$S = as.integer(Verify_Dupes$S)
Verify_Dupes$B = as.integer(Verify_Dupes$B)
Verify_Dupes$SD = as.integer(Verify_Dupes$SD)
Verify_Dupes$ED = as.integer(Verify_Dupes$ED)
Verify_Dupes$EXS = as.integer(Verify_Dupes$EXS)
Verify_Dupes$EXE = as.integer(Verify_Dupes$EXE)

# Add names to dataframe
for (i in c(1:nrow(Verify_Dupes))) {
  
  Verify_Dupes$central_name[i] = Cut_CoinFinds$cf_name[Verify_Dupes$central_cf[i] == Cut_CoinFinds$ID]
  Verify_Dupes$radius_name[i] = Cut_CoinFinds$cf_name[Verify_Dupes$radius_cf[i] == Cut_CoinFinds$ID]
  
}

# Delete CHRE
Verify_Dupes$delete = NA
for (i in c(1:nrow(Verify_Dupes))) {

  counter = 0
  cent_true = grepl("CHRE-", Verify_Dupes$central_name[i], fixed=TRUE)
  rad_true = grepl("CHRE-", Verify_Dupes$radius_name[i], fixed=TRUE)
  
  if (cent_true == TRUE) {
    counter = 1
    Verify_Dupes$delete[i] = counter} 
  if (rad_true == TRUE) {
    counter = 2
    Verify_Dupes$delete[i] = counter
  }
  if (is.na(Verify_Dupes$delete[i])) {
    Verify_Dupes$delete[i] = 0
  }
  }
  
Verify_Dupes = Verify_Dupes[Verify_Dupes$delete < 2,]


# PAS
Verify_Dupes$delete = NA
for (i in c(1:nrow(Verify_Dupes))) {

  counter = 0
  cent_true = grepl("PAS:", Verify_Dupes$central_name[i], fixed=TRUE)
  rad_true = grepl("PAS:", Verify_Dupes$radius_name[i], fixed=TRUE)
  
  if (cent_true == TRUE) {
    counter = 1
    Verify_Dupes$delete[i] = counter} 
  if (rad_true == TRUE) {
    counter = 2
    Verify_Dupes$delete[i] = counter
  }
  if (is.na(Verify_Dupes$delete[i])) {
    Verify_Dupes$delete[i] = 0
  }
  }
  
Verify_Dupes = Verify_Dupes[Verify_Dupes$delete < 2,]

#user(PeterPhilips)
Verify_Dupes$delete = NA
philips_sub = Cut_CoinFinds$ID[Cut_CoinFinds$cf_user=="PeterPhilips"]
for (i in c(1:nrow(Verify_Dupes))) {

  counter = 0
  cent_true = grepl("PAS:", Verify_Dupes$central_name[i], fixed=TRUE)
  rad_true = grepl("PAS:", Verify_Dupes$radius_name[i], fixed=TRUE)
  
  if (Verify_Dupes$radius_cf[i] %in% philips_sub) {
    counter = 1
    Verify_Dupes$delete[i] = counter} 
  if (Verify_Dupes$central_cf[i] %in% philips_sub) {
    counter = 2
    Verify_Dupes$delete[i] = counter
  }
  if (is.na(Verify_Dupes$delete[i])) {
    Verify_Dupes$delete[i] = 0
  }
  }
  
Verify_Dupes = Verify_Dupes[Verify_Dupes$delete < 2,]

Verify_Dupes = Verify_Dupes[1:(ncol(Verify_Dupes)-1)]

```

******(Currently Commented Out) Disconsidered
```{r}

Verify_Dupes$disconsidered = NA
for(i in c(1:nrow(old_VerDupes))) {
  
  if(!is.na(old_VerDupes$is.it.a.match[i])) {
    
    Verify_Dupes$disconsidered[i] = TRUE
    
  } else {
    
    Verify_Dupes$disconsidered[i] = FALSE
    
  }

}

Verify_Dupes = Verify_Dupes[Verify_Dupes$disconsidered == FALSE,]


```

Histogram matching
```{r}
Hist_CoinGroups = CoinGroups
Hist_CoinGroups$date.range = NA
Hist_CoinGroups$coins.per.25 = NA 
for (i in c(1:nrow(Hist_CoinGroups))) {

  st = toString(Hist_CoinGroups$cg_start_year[i])
  st = paste(st, "-", toString(Hist_CoinGroups$cg_end_year[i]))
  Hist_CoinGroups$date.range[i] = st
  
  Hist_CoinGroups$coins.per.25[i] = Hist_CoinGroups$cg_num_coins[i] / (Hist_CoinGroups$cg_end_year[i] - Hist_CoinGroups$cg_start_year[i]) 
  }

Verify_Dupes$distribution = NA
for (i in c(1:nrow(Verify_Dupes))) {
  Central = Hist_CoinGroups[CoinGroups$cfID == Verify_Dupes$central_cf[i],]
  Radius = Hist_CoinGroups[CoinGroups$cfID == Verify_Dupes$radius_cf[i],]
  
  central_hist = data.frame(Central$date.range, Central$coins.per.25)
  radius_hist = data.frame(Radius$date.range, Radius$coins.per.25)
  
  kstest = ks.test(Central$cg_num_coins, Radius$cg_num_coins, exact = FALSE)
  if(kstest$p.value < .05) {
    Verify_Dupes$distribution[i] = TRUE
  } else {
    Verify_Dupes$distribution[i] = FALSE
  }
  
}



# Central = Hist_CoinGroups[CoinGroups$cfID == 13307,]
# Radius = Hist_CoinGroups[CoinGroups$cfID == 8497,]
# central_hist = data.frame(Central$date.range, Central$coins.per.25)
# radius_hist = data.frame(Radius$date.range, Radius$coins.per.25)
# 
barplot(Central$coins.per.25, names.arg=Central$date.range)
barplot(Radius$coins.per.25, names.arg=Radius$date.range)
# 
# ks.test(Central$cg_num_coins, Radius$cg_num_coins)
# ks.test(Central$date.range, Radius$date.range)
```


```{r message=TRUE}
#compute match scores

#fill match scores into the spread sheet
Verify_Dupes$match.score = NA
for (i in c(1:nrow(Verify_Dupes))) {
  
  if (!is.na(Verify_Dupes$EXS[i]) & !is.na(Verify_Dupes$EXE[i])) {
  composites = composite(Verify_Dupes[i, c("G", "S", "B", "SD", "ED", "EXS", "EXE")])
} else if (!is.na(Verify_Dupes$EXS[i])) {
  composites = composite(Verify_Dupes[i, c("G", "S", "B", "SD", "ED", "EXS")])
} else if (!is.na(Verify_Dupes$EXE[i])) {
  composites = composite(Verify_Dupes[i, c("G", "S", "B", "SD", "ED", "EXE")])
} else {
  composites = composite(Verify_Dupes[i, c("G", "S", "B", "SD")])
}
  
  Verify_Dupes$match.score[i] = composites
}

Verify_Dupes$test = NA
Verify_Dupes = Verify_Dupes[as.integer(Verify_Dupes$central_cf) != as.integer(Verify_Dupes$radius_cf),]
#Removing Duplicates
for (ex in c(1:nrow(Verify_Dupes))) {
  # if(as.integer(Verify_Dupes$central_cf[ex]) == as.integer(Verify_Dupes$radius_cf[ex])){
  #   Verify_Dupes = Verify_Dupes[-ex,]
  # }

  perm.test = c(as.integer(Verify_Dupes$central_cf[ex]), as.integer(Verify_Dupes$radius_cf[ex]))
  perm.test = sort(perm.test)
  perm.test = toString(perm.test)
  Verify_Dupes$test[ex] = perm.test
}

Verify_Dupes = Verify_Dupes[as.integer(Verify_Dupes$central_cf) != as.integer(Verify_Dupes$radius_cf),]
  

Verify_Dupes = Verify_Dupes[!duplicated(Verify_Dupes[,c('test')]),]
Verify_Dupes = Verify_Dupes[,1:(ncol(Verify_Dupes)-1)]
Verify_Dupes$yes.no = NA

names(Verify_Dupes)[names(Verify_Dupes) == "G"] <- "gold"
names(Verify_Dupes)[names(Verify_Dupes) == "S"] <- "silver"
names(Verify_Dupes)[names(Verify_Dupes) == "B"] <- "bronze"
names(Verify_Dupes)[names(Verify_Dupes) == "SD"] <- "start date"
names(Verify_Dupes)[names(Verify_Dupes) == "ED"] <- "end date"
names(Verify_Dupes)[names(Verify_Dupes) == "EXS"] <- "excavation start"
names(Verify_Dupes)[names(Verify_Dupes) == "EXE"] <- "excavation end"

```


#############
OUTPUTS:
Run to get a spread sheet of coin finds that aren't possible duplicates
(You will need to change the file path)
```{r}
write_xlsx(disconsidered_CFs,"/cloud/project/Not_A_Duplicate.xlsx")
```

Run to get a list of cluster IDs in a spread sheet with percent overlap between attributes of coin finds
in each cluster and avg difference (central find - radius find) between attributes
(You will need to change the file path)
```{r}
write_xlsx(FULL_clusters,"/cloud/project/Possible_Duplicates.xlsx")
```

Excel spread sheet for manual matching
```{r}
write_xlsx(Verify_Dupes,"/cloud/project/VerifyDuplicates.xlsx")
```


List of Coin Finds that were cut
```{r}
disconsidered
old_VerDupes
```



#####
UNUSED CODE

Create functions that pulls out an inputted cluster from TEST_CoinFinds and splits up the true and false list to a table
```{r}
#####Get information on a specific cluster
cluster_info = function(clusterID) {

  # pulls info of all coins in a cluster and adds clusterID
 list = as.integer(unlist(strsplit(clusterID, split=".", fixed = T)))
 cluster =  Cut_CoinFinds[Cut_CoinFinds$ID %in% list,]
 cluster = subset(cluster, select = -c(cf_place_name,cf_custom_place_name, cf_custom_region, cf_custom_region_vague, cf_vague, cf_comment, cf_date_entered, Exported.at, cf_publication_ref, cf_user, Coin.Find.Json, in.radius) )
 cluster$clusterID = c(rep(clusterID, rep=nrow(cluster)))
 
 #beginning to reformat the TRUE/FALSE lists
 ref_are.num.coins.same = unlist(cluster$are.num.coins.same[1])
 
 ref_is.silver.same = unlist(cluster$is.silver.same[1])
 ref_is.gold.same = unlist(cluster$is.gold.same[1])
 ref_is.bronze.same = unlist(cluster$is.bronze.same[1])
 ref_is.lead.same = unlist(cluster$is.lead.same[1])
 ref_total.silver = unlist(cluster$total.silver[1])
 ref_total.gold = unlist(cluster$total.gold[1])
 ref_total.bronze = unlist(cluster$total.bronze[1])
 ref_total.lead = unlist(cluster$total.lead[1])
 
 ref_are.excav.start.same = unlist(cluster$are.excav.start.same[1])
 ref_are.excav.end.same = unlist(cluster$are.excav.end.same[1])
 
 ref_is.cf.start.year.same = unlist(cluster$is.cf.start.year.same[1])
 ref_is.cf.end.year.same = unlist(cluster$is.cf.end.year.same[1])
 
 #putting TRUE/FALSEs into the cluster data frame
 for(z in c(1:nrow(cluster))) {
   
   cluster$are.num.coins.same[z] = ref_are.num.coins.same[z]
   
   cluster$is.silver.same[z] = ref_is.silver.same[z]
   cluster$is.gold.same[z] = ref_is.gold.same[z]
   cluster$is.bronze.same[z] = ref_is.bronze.same[z]
   cluster$is.lead.same[z] = ref_is.lead.same[z]
   
   cluster$total.silver[z] = ref_total.silver[z]
   cluster$total.gold[z] = ref_total.gold[z]
   cluster$total.bronze[z] = ref_total.bronze[z]
   cluster$total.lead[z] = ref_total.lead[z]   
   
   cluster$are.excav.start.same[z] = ref_are.excav.start.same[z]
   cluster$are.excav.end.same[z] = ref_are.excav.end.same[z]
   cluster$is.cf.start.year.same[z] = ref_is.cf.start.year.same[z]
   cluster$is.cf.end.year.same[z] = ref_is.cf.end.year.same[z]
   
 }
 
#reformat dataframe for easier comparison
col_order <- c("ID", "cf_name", "cf_custom_x_coordinate","cf_custom_y_coordinate",
               "clusterID", "num.in.radius", 
               "cf_excavation_start", "are.excav.start.same", "cf_excavation_end", "are.excav.end.same", "cf_excavation_name", "cf_excavation", "cf_single_find", "cf_hoard",
               "cf_start_year", "is.cf.start.year.same", "cf_end_year", "is.cf.end.year.same",
               "cf_num_coins_found", "are.num.coins.same",
               "total.gold", "is.gold.same", "total.silver", "is.silver.same", "total.bronze", "is.bronze.same", "total.lead", "is.lead.same")
cluster <- cluster[, col_order]
 
return(cluster)
}

```

Creating a smaller subset of coin finds more likely to be duplicates
```{r}
At_Least_One_Match = FULL_clusters[FULL_clusters$percent.num.coins.same>0 | FULL_clusters$percent.start.date.same>0 | FULL_clusters$percent.end.date.same>0 | (FULL_clusters$percent.bronze.same>0 & FULL_clusters$is.bronze.zero==FALSE) | 
 (FULL_clusters$percent.silver.same>0 & FULL_clusters$is.silver.zero==FALSE) |
   (FULL_clusters$percent.gold.same>0 & FULL_clusters$is.gold.zero==FALSE) |
   (FULL_clusters$percent.lead.same>0 & FULL_clusters$is.lead.zero==FALSE),]

At_Least_Three_Match = At_Least_One_Match[FULL_clusters$how.many.matches>=3,]
```

This is a shortened version of this spread sheet that only keeps one of the coin find entries for each cluster.
```{r}
nodupes_clusters = FULL_clusters[!duplicated(FULL_clusters$clusterID), ]
write_xlsx(nodupes_clusters,"/cloud/project/Short_Clusters.xlsx")
```

This is the same as above but only clusters that match on at least one other attribute other than 
location
```{r}
write_xlsx(At_Least_One_Match,"/cloud/project/At_Least_One_Match.xlsx")
```

Input: a cluster ID (change the file path)
Output: a spread sheet and data frame of the info on a specific cluster
```{r}
####INPUT####
cluster = cluster_info("7920.7921.13298.13299")
write_xlsx(cluster,"/cloud/project/cluster.xlsx")
```

Match Score draft
```{r}
#Adding one more column to FULL_clusters:
#Match Score
FULL_clusters$how.many.matches = NA

for (i in c(1:nrow(FULL_clusters))) {
  counter = 0
  
  if (FULL_clusters$percent.num.coins.same[i] > 0) {
    counter = counter+1
  }
  
  if (FULL_clusters$percent.start.date.same[i] > 0) {
    counter = counter+1
  }
  
  if (FULL_clusters$percent.end.date.same[i] > 0) {
    counter = counter+1
  }
  
  if (FULL_clusters$percent.silver.same[i]>0 & FULL_clusters$is.silver.zero[i]==FALSE) {
    counter = counter+1
  }
  
  if (FULL_clusters$percent.gold.same[i]>0 & FULL_clusters$is.gold.zero[i]==FALSE) {
    counter = counter+1
  }
  
  if (FULL_clusters$percent.lead.same[i]>0 & FULL_clusters$is.lead.zero[i]==FALSE) {
    counter = counter+1
  }
  
  if (FULL_clusters$percent.bronze.same[i]>0 & FULL_clusters$is.bronze.zero[i]==FALSE) {
    counter = counter+1
  }
  
  FULL_clusters$how.many.matches[i] = counter
}

```

```{r}
# verID = 1
# #nrow(FULL_clusters)
# for (i in c(1:30)) {
#   full = i
# 
#   #put central find in row
#   Verify_Dupes$central_cf[verID] = FULL_clusters$cfID[full]
#   
#   # make list of cluster IDs  
#   cluster.list = strsplit(FULL_clusters$clusterID[full], ".", fixed=T)
#   for (l in c(1:length(cluster.list[[1]]))){
#     x = l
#     # put rad ID in row
#     Verify_Dupes$radius_cf[verID] = cluster.list[[1]][[x]]
#     #print(Verify_Dupes$radius_cf[verID-1])
#   
#     if(x != (length(cluster.list)-1) & x != (length(cluster.list))) {
#       verID = verID + 1
#       Verify_Dupes[nrow(Verify_Dupes) + 1, ] <- c(NA, NA)
#       Verify_Dupes$central_cf[verID] = FULL_clusters$cfID[full] }
#     
#   }
#   
#   #add new row to Verify Duplicates
#   verID = verID + 1
#   Verify_Dupes[nrow(Verify_Dupes) + 1, ] <- c(NA, NA)
#     
#   }
```






